<html>
<head>
<link rel="stylesheet" href="manpage.css"><title>tDOM manual: schema</title><meta name="xsl-processor" content="Jochen Loewer (loewerj@hotmail.com), Rolf Ade (rolf@pointsman.de) et. al."><meta name="generator" content="$RCSfile: tmml-html.xsl,v $ $Revision: 1.11 $"><meta charset="utf-8">
</head><body>
<div class="header">
<div class="navbar" align="center">
<a href="#SECTid0x55d81f852b30">NAME</a> · <a href="#SECTid0x55d81f853160">SYNOPSIS</a> · <a href="#SECTid0x55d81f84d5d0">DESCRIPTION </a> · <a href="#SECTid0x55d81f8ab7e0">Schema definition scripts</a> · <a href="#SECTid0x55d81f8b3b10">Quantity specifier</a> · <a href="#SECTid0x55d81f8b59a0">Text constraint scripts</a> · <a href="#SECTid0x55d81f8bcfc0">Exampels</a>
</div><hr class="navsep">
</div><div class="body">
  <h2><a name="SECTid0x55d81f852b30">NAME</a></h2><p class="namesection">
<b class="names">tdom::schema - </b><br>Create a schema validation command</p>

  <h2><a name="SECTid0x55d81f853160">SYNOPSIS</a></h2><pre class="syntax">package require tdom

<b class="cmd">tdom::schema</b> <i class="m">?create?</i> <i class="m">cmdName</i>
    </pre>

  <h2><a name="SECTid0x55d81f84d5d0">DESCRIPTION </a></h2><p>This command creates validation commands with a simple API. The
    validation commands have methods to define a schema and are able
    to validate XML or DOM trees (and to some degree other kind of
    hierarchical data) against this schema.</p><p>Additionally, a validation command may be used as argument to
    the <i class="m">-validateCmd</i> option of the <i class="m">dom parse</i> and the
    <i class="m">expat</i> commands to enable validation additional to what they
    otherwise do.</p><p>The valid methods of the created commands are:</p><dl class="commandlist">
      
        <dt>
<b class="method">defelement</b> <i class="m">name</i> <i class="m">?namespace?</i> <i class="m">&lt;definition script&gt;</i>
</dt>
        <dd>This method defines the element <i class="m">name</i> (optional in
        the namespace <i class="m">namespace</i>) in the schema. The
        <i class="m">definition script</i> is evaluated and defines the content
        model of the element. If the <i class="m">namespace</i> argument is
        given, any <i class="m">element</i> or <i class="m">ref</i> references in the
        definition script not wrapped inside a <i class="m">namespace</i>
        command are resolved in that namespace. If there is already a
        element definition for the name/namespace combination the
        command raises error.</dd>
      

      
        <dt>
<b class="method">defpattern</b> <i class="m">name</i> <i class="m">?namespace?</i> <i class="m">&lt;definition script&gt;</i>
</dt>
        <dd>This method defines a (maybe complex) content particle
        with the <i class="m">name</i> (optional in the namespace
        <i class="m">namespace</i>) in the schema, to be referenced in other
        definition scripts with the definition command <i class="m">ref</i>. The
        <i class="m">definition script</i> is evaluated and defines the content
        model of the content particle. If the <i class="m">namespace</i>
        argument is given, any <i class="m">element</i> or <i class="m">ref</i> references
        in the definition script not wrapped inside a <i class="m">namespace</i>
        command are resolved in that namespace. If there is already a
        pattern definition for the name/namespace combination the
        command raises error.</dd>
      

      
        <dt>
<b class="method">define</b> <i class="m">&lt;definition script&gt;</i>
</dt>
        <dd>This method allows to define several elements or pattern
        or a whole schema with one call.</dd>
      
      
      
        <dt>
<b class="method">start</b> <i class="m">documentElement</i> <i class="m">?namespace?</i>
</dt>
        <dd>This method defines the name and namespace of the root
        element of a tree to validate. If this method is used then the
        root element must match for validity. If <i class="m">start</i> isn't
        used, any with <i class="m">defelement</i> defined element may be the
        root of a valid document. The <i class="m">start</i> method may be used
        serveral times with varying arguments during the lifetime of a
        validation command. If the command is called with just the
        empty string (and no namespace argument), the validation
        constrain for the root element is removed and any defined
        element will be valid as root of a tree to validate.</dd>
      

      
        <dt>
<b class="method">event</b> <i class="m">(start|end|text)</i> <i class="m">?event specific data?</i>
</dt>
        <dd>This method allows to validate hierarchical data against
        the content constrains of the validation command.

        <dl class="optlist">
          
            <dt>
<b>start</b> <i>name ?attributes? ?namespace? </i>
</dt>
            
            <dd>Checks if the current validation state allows the
            element <i class="m">name</i> in the <i class="m">namespace</i> is allowed to
            start here. It raises error, if not.</dd>
          

          
            <dt><b>end</b></dt>
            <dd>Checks if the current innermost open element may end
            here in the current state without violate validation
            constrains. It raises error, if not.</dd>
          
          
          
            <dt>
<b>text</b> <i>text</i>
</dt>
            
            <dd>Checks if the current validation state allows the
            given text content. It raises error, if not.</dd>
          

        </dl>
        </dd>
      

      
        <dt>
<b class="method">validate</b> <i class="m">&lt;XML string&gt;</i> <i class="m">?objVar?</i>
</dt>
        <dd>Returns true if the <i class="m">&lt;XML string&gt;</i> is valid or
        false otherwise. If validation failed and the optional
        <i class="m">objVar</i> argument is given, then the variable with that
        name is set to a validation error message. If the XML string
        is valid and the optional <i class="m">objVar</i> argument is given,
        then the variable with that name is set to the empty string.</dd>
      

      
        <dt>
<b class="method">domvalidate</b> <i class="m">domNode</i> <i class="m">?objVar?</i>
</dt>
        <dd>Returns true if the first argument is a valid tree or
        false otherwise. If validation failed and the optional
        <i class="m">objVar</i> argument is given, then the variable with that
        name is set to a validation error message. If the dom tree is
        valid and the optional <i class="m">objVar</i> argument is given, then
        the variable with that name is set to the empty string. </dd>
      
      
      
        <dt><b class="method">delete</b></dt>
        <dd>This method deletes the validation command.</dd>
      

      
        <dt><b class="method">state</b></dt>
        <dd>This method returns the state of the validation command
        with respect to validation state. The possible return values
        and their meanings are:
        <dl>
          <dt>READY</dt><dd>The validation command is ready to start
          validation</dd>
          <dt>VALIDATING</dt><dd>The validation command is in the
          process of validating input.</dd>
          <dt>FINISHED</dt><dd>The validation has finished, no futher
          events are expected.</dd>
        </dl>
        </dd>
      
      
      
        <dt><b class="method">reset</b></dt>
        <dd>This method resets the validation command into state
        READY (while preserving the defined grammer).</dd>
      

    </dl>

  <h2><a name="SECTid0x55d81f8ab7e0">Schema definition scripts</a></h2><p>Schema definition scripts are ordinary Tcl scripts that are
    evaluatend in the namespace tdom::schema. The below listed schema
    definition commands in this tcl namespace allow to define a wide
    variety of document structures. Every schema definition command
    establish a validation constraint on the content which has to
    match or must be optional to render the content as valid. It is a
    validation error if the element in the XML source has additional
    (not matched) content.</p><p>The schema definition commands are:</p><dl class="commandlist">
      
        <dt>
<b class="method">element</b> <i class="m">name</i> <i class="m">?quant?</i> <i class="m">?&lt;definition script&gt;?</i>
</dt>
        <dd>If the optional argument <i class="m">definition script</i> isn't
        given this command refers to the element defined with
        <i class="m">defelement</i> with the name <i class="m">name</i> in the current
        context namespace. If the <i class="m">defelement script</i> argument is
        given, then the validation constraint expects an element with
        the name <i class="m">name</i> in the current namespace with content
        "locally" defined by the <i class="m">definition script</i>. Forward
        references to so far not defined elements or pattern or other
        local definitions of the same name inside the <i class="m">definition
        script</i> are allowed. </dd>
      

      
        <dt>
<b class="method">ref</b> <i class="m">name</i> <i class="m">?quant?</i>
</dt>
        <dd>This command refers to the content particle defined with
        <i class="m">defpattern</i> with the name <i class="m">name</i> in the current context
        namespace. Forward references to a so far not defined pattern
        or recursive references are allowed.</dd>
      

      
        <dt>
<b class="method">group</b> <i class="m">?quant?</i> <i class="m">&lt;definition script&gt;</i>
</dt>
        <dd></dd>
      
      
      
        <dt>
<b class="method">choice</b> <i class="m">?quant?</i> <i class="m">&lt;definition script&gt;</i>
</dt>
        <dd></dd>
      

      
        <dt>
<b class="method">interleave</b> <i class="m">?quant?</i> <i class="m">&lt;definition script&gt;</i>
</dt>
        <dd></dd>
      

      
        <dt>
<b class="method">mixed</b> <i class="m">?quant?</i> <i class="m">&lt;definition script&gt;</i>
</dt>
        <dd></dd>
      

      
        <dt>
<b class="method">text</b> <i class="m">?&lt;constraint script&gt;|"type" typename?</i>
</dt>
        <dd>Without the optional constraint script this validation
        constraint matches every string (including the empty one).
        With <i class="m">constraint script</i> or with a given text type
        argument a text matching this script or the text type is
        expected. </dd>
      

      
        <dt>
<b class="method">any</b> <i class="m">?quant?</i>
</dt>
        <dd>The any command matches every element (with whatever
        attributes) or subtree, no matter if known within the schema
        or not. Please notice, that this mean the quantifier * and +
        will eat up any elements until the enclosing element
        ends.</dd>
      

      
        <dt>
<b class="method">attribute</b> <i class="m">name</i> <i class="m">?quant?</i> <i class="m">(?&lt;constraint script&gt;|"type" typename?)</i>
</dt>
        <dd>The attribute command defines a attribute (in no
        namespace) to the enclosing element. The first definition of
        <i class="m">name</i> inside an element definition wins; later
        definitions of the same name are silently ignored. After the
        <i class="m">name</i> argument there may be one of the qunatifieres ? or
        !. If there is, this will be used. Otherwise the attribute
        will be required (must be present in the xml source). If there
        is one argument more this argument is evaluated as constraint
        script, defining the value constrains of the attribute.
        Otherwise, if there are two more arguments and the first of
        them is the bareword "type" then the following is used as a
        text type name.</dd>
      

      
        <dt>
<b class="method">nsattribute</b> <i class="m">name</i> <i class="m">namespace</i> <i class="m">?quant?</i> <i class="m">(?&lt;constraint script&gt;|"type" typename?)</i>
</dt>
        <dd>This command does the same as the command <i class="m">attribute</i>, just for the attribute <i class="m">name</i> in the namespace <i class="m">namespace</i>.</dd>
      

      
        <dt>
<b class="method">namespace</b> <i class="m">uri</i> <i class="m">&lt;definition script&gt;</i>
</dt>
        <dd>Evaluates the <i class="m">definition script</i> with context namespace <i class="m">uri</i>. Every element or ref command name will be looked up in the namespace <i class="m">uri</i> and local defined element will be in that namespace.</dd>
      
      
      
        <dt>
<b class="method">defelement</b> <i class="m">name</i> <i class="m">?namespace?</i> <i class="m">&lt;definition script&gt;</i>
</dt>
        <dd>This defines an element type exactly as a <i>schemacmd
        defelement</i> call. This is meant as toplevel command of a
        <i>schemacmd define</i> script. This command is not allowed
        nested in an other definition script command and will raise
        error, if you call it there.</dd>
      

      
        <dt>
<b class="method">defpattern</b> <i class="m">name</i> <i class="m">?namespace?</i> <i class="m">&lt;definition script&gt;</i>
</dt>
        <dd>This defines a named pattern exactly as a <i>schemacmd
        defpattern</i> call. This is meant as toplevel command of a
        <i>schemacmd define</i> script. This command is not allowed
        nested in an other definition script command and will raise
        error, if you call it there.</dd>
      

      
        <dt>
<b class="method">start</b> <i class="m">name</i> <i class="m">?namespace?</i>
</dt>
        <dd>This command works exactly as a <i>schemacmd start</i>
        call. This is meant as toplevel command of a <i>schemacmd
        define</i> script. This command is not allowed nested in an
        other definition script command and will raise error, if you
        call it there.</dd>
      
    </dl>

  <h2><a name="SECTid0x55d81f8b3b10">Quantity specifier</a></h2><p>Serveral schema definition commands expects a quantifier as
    one of their arguments, which specifies how often the content
    particle specified by the command is expected. The valid values
    for a <i class="m">quant</i> argument are:</p><dl class="optlist">
      
        <dt><b>!</b></dt>
        <dd>The content particle must occur exactly once in valid
        documents. This is the default, if a quantifier is
        omitted.</dd>
      
    
      
        <dt><b>?</b></dt>
        <dd>The content particle must occur at most once in valid
        documents.</dd>
      
    
      
        <dt><b>*</b></dt>
        <dd>The content particle may occur zero or more times in a
        row in valid documents.</dd>
      
    
      
        <dt><b>+</b></dt>
        <dd>The content particle may occur one or more times in a
        row in valid documents.</dd>
      
    
      
        <dt><b>n</b></dt>
        <dd>The content particle must occur n times in a row in
        valid documents. The quantifier must be an integer greater
        zero.</dd>
      
    
      
        <dt><b>{n m}</b></dt> <dd>The content particle must occur
        n to m times (both inclusive) in a row in valid documents. The
        quantifier must be a tcl list with two elements. Both elements
        must be integers, with n &gt;= 0 and n &lt; m.</dd>
      
    </dl><p>If an optional quantifier is not given then it defaults to * in
    case of the mixed command and to ! for all other commands.</p>

  <h2><a name="SECTid0x55d81f8b59a0">Text constraint scripts</a></h2><p></p><p>The text constraint commands are:</p><dl class="commandlist">
      
        <dt><b class="cmd">isint</b></dt>
        <dd></dd>
      

      
        <dt>
<b class="cmd">fixed</b> <i class="m">value</i>
</dt>
        <dd></dd>
      
      
      
        <dt>
<b class="cmd">tcl</b> <i class="m">tclcmd</i> <i class="m">?arg arg ...?</i>
</dt>
        <dd>Evaluates the tcl script <i class="m">tclcmd arg arg ... </i> and
        the text to validate appended to the argument list. The return
        value of the tcl command is interpreted as a boolean.</dd>
      
      
        <dt>
<b class="cmd">enumeration</b> <i class="m">list</i>
</dt>
        <dd>This text constraint match if the text value is equal to
        one element (respecting case and any whitespace) of the
        argument <i class="m">list</i>, which has to be a valid Tcl list.
        </dd>
      
      
        <dt>
<b class="cmd">match</b> <i class="m">?-nocase?</i> <i class="m">glob style match pattern</i>
</dt>
        <dd>This text constraint match if the text value match the
        glob style pattern given as argument. It follows the rules of
        the Tcl [string match] command, see
        <a href="https://www.tcl.tk/man/tcl8.6/TclCmd/string.htm#M35">https://www.tcl.tk/man/tcl8.6/TclCmd/string.htm#M35</a>.</dd>
      
      
        <dt>
<b class="cmd">regexp</b> <i class="m">expression</i>
</dt>
        <dd>This text constraint match if the text value match the
        regular expression given as argument. <a href="https://www.tcl.tk/man/tcl8.6/TclCmd/re_syntax.htm">https://www.tcl.tk/man/tcl8.6/TclCmd/re_syntax.htm</a> describes the regular expression syntax</dd>
      
      
        <dt><b class="cmd">nmtoken</b></dt>
        <dd>This text constraint match if the text value match the
        XML nmtoken production
        <a href="https://www.w3.org/TR/xml/#NT-Nmtoken">https://www.w3.org/TR/xml/#NT-Nmtoken</a>
</dd>
      
      
        <dt><b class="cmd">nmtokens</b></dt>
        <dd>This text constraint match if the text value match the
        XML nmtokens production
        <a href="https://www.w3.org/TR/xml/#NT-Nmtokens">https://www.w3.org/TR/xml/#NT-Nmtokens</a>
</dd>
      
      
        <dt><b class="cmd">number</b></dt>
        <dd></dd>
      
      
        <dt><b class="cmd">boolean</b></dt>
        <dd></dd>
      
      
        <dt><b class="cmd">isodate</b></dt>
        <dd></dd>
      
      
        <dt>
<b class="cmd">maxLength</b> <i class="m">length</i>
</dt>
        <dd>This text constraint match if the length of the text
        value (in characters, not bytes) is at most <i class="m">length</i>. The
        length argument must be an integer greater zero.</dd>
      
      
        <dt>
<b class="cmd">minLength</b> <i class="m">length</i>
</dt>
        <dd>This text constraint match if the length of the text
        value (in characters, not bytes) is at least <i class="m">length</i>.
        The length argument must be an integer greater zero.</dd>
      
      
        <dt>
<b class="cmd">oneOf</b> <i class="m">&lt;constraint script&gt;</i>
</dt>
        <dd>This text constraint match if one of the text
        constraints defined in the argument <i class="m">constraint script</i>
        match the text. It stops after the first match and probes the
        text constraints in the order of definition.</dd>
      
      
        <dt>
<b class="cmd">allOf</b> <i class="m">&lt;constraint script&gt;</i>
</dt>
        <dd>This text constraint match if all of the text
        constraints defined in the argument <i class="m">constraint script</i>
        match the text. It stops after the first match failues and
        probes the text constraints in the order of definition. Since
        the schema definition commmand <i class="m">text</i> also expects all
        text constraints to match the text constraint <i class="m">allOf</i> is
        useful mostly together with the <i class="m">oneOf</i> text constraint
        commmand.</dd>
      
      
        <dt>
<b class="cmd">strip</b> <i class="m">&lt;constraint script&gt;</i>
</dt>
        <dd>This text constraint command tests all text constraints
        in the evaluated <i class="m">constraint script&gt;</i> with the text to
        test striped of all white space at start and end.</dd>
      
      
        <dt>
<b class="cmd">split</b> <i class="m">?type ?args??</i><i class="m">&lt;constraint script&gt;</i>
</dt>
        <dd>
<p>This text constraint command splits the text to test
        into a list of values and tests all elements of that list for
        the text constraints in the evaluated <i class="m">constraint
        script&gt;</i>.</p>
        <p>The available types are:</p>
        <dl>
            <dt>whitespace</dt><dd>The text to split is striped of all
            white space at start and end splited into a list at any
            successive white space.</dd>
            <dt>tcl tclcmd ?arg ...?</dt><dd>The text to split is
            handed to the <i class="m">tclcmd</i>, which is evaluated on global
            level, appended with every given arg and the text to split
            as last argument. This call must return a valid tcl list,
            which elements are tested..</dd>
        </dl>
        <p>The default in case no split type argument is given is
        <i class="m">whitespace</i>.</p>
</dd>
      
    </dl>
  
  <h2><a name="SECTid0x55d81f8bcfc0">Exampels</a></h2><p>The XML Schema Part 0: Primer Second Edition
    (<a href="https://www.w3.org/TR/xmlschema-0/">https://www.w3.org/TR/xmlschema-0/</a>) starts with this
    example schema:</p><pre class="example">
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;xsd:annotation&gt;
    &lt;xsd:documentation xml:lang="en"&gt;
     Purchase order schema for Example.com.
     Copyright 2000 Example.com. All rights reserved.
    &lt;/xsd:documentation&gt;
  &lt;/xsd:annotation&gt;

  &lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/&gt;

  &lt;xsd:element name="comment" type="xsd:string"/&gt;

  &lt;xsd:complexType name="PurchaseOrderType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="shipTo" type="USAddress"/&gt;
      &lt;xsd:element name="billTo" type="USAddress"/&gt;
      &lt;xsd:element ref="comment" minOccurs="0"/&gt;
      &lt;xsd:element name="items"  type="Items"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="USAddress"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="name"   type="xsd:string"/&gt;
      &lt;xsd:element name="street" type="xsd:string"/&gt;
      &lt;xsd:element name="city"   type="xsd:string"/&gt;
      &lt;xsd:element name="state"  type="xsd:string"/&gt;
      &lt;xsd:element name="zip"    type="xsd:decimal"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="country" type="xsd:NMTOKEN"
                   fixed="US"/&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="Items"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xsd:complexType&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element name="productName" type="xsd:string"/&gt;
            &lt;xsd:element name="quantity"&gt;
              &lt;xsd:simpleType&gt;
                &lt;xsd:restriction base="xsd:positiveInteger"&gt;
                  &lt;xsd:maxExclusive value="100"/&gt;
                &lt;/xsd:restriction&gt;
              &lt;/xsd:simpleType&gt;
            &lt;/xsd:element&gt;
            &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;
            &lt;xsd:element ref="comment"   minOccurs="0"/&gt;
            &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;
          &lt;/xsd:sequence&gt;
          &lt;xsd:attribute name="partNum" type="SKU" use="required"/&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Stock Keeping Unit, a code for identifying products --&gt;
  &lt;xsd:simpleType name="SKU"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

&lt;/xsd:schema&gt;
    </pre><p>A somewhat one-to-one translation of that into a tDOM schema
    defintion script would be:</p><pre class="example">
tdom::schema schema      
schema define {

    # Purchase order schema for Example.com.
    # Copyright 2000 Example.com. All rights reserved.

    element purchaseOrder {ref PurchaseOrderType}

    element comment {text}

    defpattern PurchaseOrderType {
        element shipTo {ref USAddress}
        element billTo {ref USAddress}
        element comment ?
        element items
        attribute orderDate
    }

    defpattern USAddress {
        element name ! {text}
        element street ! {text}
        element city ! {text}
        element state ! {text}
        element zip ! {text isNumber}
        attribute country ! {text {fixed "US"}}
    }

    defelement items {
        element item * {
            element product ! {text}
            element quntity ! {text {maxExcluse 100}}
            element USPrice ! {text isNumber}
            element comment
            element shipDate ? {text isDate}
            attribute partNum ! {text {pattern "\d{3}-[A-Z]{2}"}}
        }
    }
}
      
    </pre><p>The RELAX NG Tutorial
    (<a href="http://relaxng.org/tutorial-20011203.html">http://relaxng.org/tutorial-20011203.html</a>) starts with
described at     this example:</p><pre class="example">
Consider a simple XML representation of an email address book:

&lt;addressBook&gt;
  &lt;card&gt;
    &lt;name&gt;John Smith&lt;/name&gt;
    &lt;email&gt;js@example.com&lt;/email&gt;
  &lt;/card&gt;
  &lt;card&gt;
    &lt;name&gt;Fred Bloggs&lt;/name&gt;
    &lt;email&gt;fb@example.net&lt;/email&gt;
  &lt;/card&gt;
&lt;/addressBook&gt;

The DTD would be as follows:

&lt;!DOCTYPE addressBook [
&lt;!ELEMENT addressBook (card*)&gt;
&lt;!ELEMENT card (name, email)&gt;
&lt;!ELEMENT name (#PCDATA)&gt;
&lt;!ELEMENT email (#PCDATA)&gt;
]&gt;

A RELAX NG pattern for this could be written as follows:

&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;
      
    </pre><p>This schema definition script will do the same:</p><pre class="example">
tdom::schema schema      
schema define {
    defelement addressBook {
        element card *
    }
    defelement card {
        element name
        element email
    }
    foreach e {name email} {
        defelement $e {text}
    }
}
      
    </pre>
</div><hr class="navsep"><div class="navbar" align="center">
<a class="navaid" href="index.html">Contents</a> · <a class="navaid" href="category-index.html">Index</a> · <a class="navaid" href="keyword-index.html">Keywords</a> · <a class="navaid" href="http://tdom.org">Repository</a>
</div>
</body>
</html>
