<manpage id="schema" cat="schema" title="schema">
  <namesection>
    <name>tdom::schema</name>
    <desc>Create a schema validation command</desc>
  </namesection>

  <synopsis>
    <syntax>package require tdom

<cmd>tdom::schema</cmd> <m>?create?</m> <m>cmdName</m>
    </syntax>
  </synopsis>

  <section>
    <title>DESCRIPTION </title>    
    
    <p>This command creates validation commands with a simple API. The
    validation commands have methods to define a schema and are able
    to validate XML data or to post-validate a tDOM DOM tree (and to
    some degree other kind of hierarchical data) against this
    schema.</p>

    <p>Additionally, a validation command may be used as argument to
    the <m>-validateCmd</m> option of the <m>dom parse</m> and the
    <m>expat</m> commands to enable validation additional to what they
    otherwise do.</p>

    <p>The valid methods of the created commands are:</p>

    <commandlist>
      <commanddef>
          <command><method>prefixns</method> <m>?prefixUriList?</m></command>
          <desc>This method gives control to a prefix (or
          abbreviation) to namespace URI mapping. Everywhere a
          namespace argument is expected in the schema command methods
          you may use the &quot;prefix&quot; pointing to the namespace
          URI in the current prefixUriList, set by this method. If the
          list map the same prefix to different namespace URIs the
          frist one win. If there isn't such a prefix the namespace
          argument is used literally as namespace URI. If the method
          is called without argument it returns the current
          prefixUriList. If the method is called with the empty string
          any namespace URI arguments are used literally. This is the
          default.
          </desc>
      </commanddef>

      <commanddef>
        <command><method>defelement</method> <m>name</m> <m>?namespace?</m> <m>&lt;definition script></m></command>
        <desc>This method defines the element <m>name</m> (optional in
        the namespace <m>namespace</m>) in the schema. The
        <m>definition script</m> is evaluated and defines the content
        model of the element. If the <m>namespace</m> argument is
        given, any <m>element</m> or <m>ref</m> references in the
        definition script not wrapped inside a <m>namespace</m>
        command are resolved in that namespace. If there is already a
        element definition for the name/namespace combination the
        command raises error.</desc>
      </commanddef>

      <commanddef>
        <command><method>defelementtype</method> <m>typename</m> <m>name</m> <m>?namespace?</m> <m>&lt;definition script></m></command>
        <desc>This method defines the elementtype <m>typename</m>
        (optional in the namespace <m>namespace</m>) in the schema. If
        the element type is refered in a definition script with the
        schema command elementype the validation engine expects an
        elment namend <m>name</m> (in the namespace <m>namespace</m>,
        if given) and the content model <m>definition script</m>.
        Defining element types seems only sensible if you really have
        elments with the same name and namespache but different
        content models. The <m>definition script</m> is evaluated and
        defines the content model of the element. If the
        <m>namespace</m> argument is given, any <m>element</m> or
        <m>ref</m> references in the definition script not wrapped
        inside a <m>namespace</m> command are resolved in that
        namespace. If there is already a elementtype definition for
        the name/namespace combination the command raises
        error.</desc>
      </commanddef>

      <commanddef>
        <command><method>defpattern</method> <m>name</m> <m>?namespace?</m> <m>&lt;definition script></m></command>
        <desc>This method defines a (maybe complex) content particle
        with the <m>name</m> (optional in the namespace
        <m>namespace</m>) in the schema, to be referenced in other
        definition scripts with the definition command <m>ref</m>. The
        <m>definition script</m> is evaluated and defines the content
        model of the content particle. If the <m>namespace</m>
        argument is given, any <m>element</m> or <m>ref</m> references
        in the definition script not wrapped inside a <m>namespace</m>
        command are resolved in that namespace. If there is already a
        pattern definition for the name/namespace combination the
        command raises error.</desc>
      </commanddef>

      <commanddef>
        <command><method>deftext</method> <m>name</m> <m>&lt;constraint script></m></command>
        <desc>This method defines a bundle of text constraints, that
        can be referred by <m>name</m> while defining constrains on
        text element or attribute values. If there is already a text
        type definition with this name, the command raises error. A
        text type must be defined before it can be used in schema
        definition scripts.</desc>
      </commanddef>
      
      <commanddef>
        <command><method>start</method> <m>documentElement</m> <m>?namespace?</m></command>
        <desc>This method defines the name and namespace of the root
        element of a tree to validate. If this method is used then the
        root element must match for validity. If <m>start</m> isn't
        used, any with <m>defelement</m> defined element may be the
        root of a valid document. The <m>start</m> method may be used
        serveral times with varying arguments during the lifetime of a
        validation command. If the command is called with just the
        empty string (and no namespace argument), the validation
        constrain for the root element is removed and any defined
        element will be valid as root of a tree to validate.</desc>
      </commanddef>

      <commanddef>
        <command><method>define</method> <m>&lt;definition script></m></command>
        <desc>This method allows to define several elements or pattern
        or a whole schema with one call. All schema command methods so
        far (<m>prefixns</m>, <m>defelement</m>,
        <m>defelementtype</m>, <m>defpattern</m>, <m>deftext</m> and
        <m>start</m>) are allowed top level in the <m>definition
        script</m>. The <m>define</m> method itself isn't allowed
        recursively.</desc>
      </commanddef>
      
      <commanddef>
        <command><method>event</method> <m>(start|end|text)</m> <m>?event specific data?</m></command>
        <desc>This method allows to validate hierarchical data against
        the content constrains of the validation command.

        <optlist>
          <optdef>
            <optname>start</optname>
            <optarg>name ?attributes? ?namespace? </optarg>
            <desc>Checks if the current validation state allows the
            element <m>name</m> in the <m>namespace</m> is allowed to
            start here. It raises error, if not.</desc>
          </optdef>

          <optdef>
            <optname>end</optname>
            <desc>Checks if the current innermost open element may end
            here in the current state without violate validation
            constrains. It raises error, if not.</desc>
          </optdef>
          
          <optdef>
            <optname>text</optname>
            <optarg>text</optarg>
            <desc>Checks if the current validation state allows the
            given text content. It raises error, if not.</desc>
          </optdef>
        </optlist>
        </desc>
      </commanddef>

      <commanddef>
        <command><method>validate</method> <m>&lt;XML string></m> <m>?objVar?</m></command>
        <desc>Returns true if the <m>&lt;XML string></m> is valid or
        false otherwise. If validation failed and the optional
        <m>objVar</m> argument is given, then the variable with that
        name is set to a validation error message. If the XML string
        is valid and the optional <m>objVar</m> argument is given,
        then the variable with that name is set to the empty string.</desc>
      </commanddef>

      <commanddef>
        <command><method>validatefile</method> <m>filename</m> <m>?objVar?</m></command>
        <desc>Returns true if the content of <m>filename</m> is valid
        or false otherwise. The given file is feeded as binary stream
        to expat, therefor only US-ASCII, ISO-8859-1, UTF-8 or UTF-16
        encoded data will work with this method. If validation failed
        and the optional <m>objVar</m> argument is given, then the
        variable with that name is set to a validation error message.
        If the XML string is valid and the optional <m>objVar</m>
        argument is given, then the variable with that name is set to
        the empty string.</desc>
      </commanddef>

      <commanddef>
        <command><method>validatechannel</method> <m>channel</m> <m>?objVar?</m></command>
        <desc>Returns true if the content read ouf of the tcl channel
        <m>channel</m> is valid or false otherwise. Since data read
        out of a tcl channel is UTF-8 encoded any misleading encoding
        declaration at the beginning of the data will lead to errors.
        If the validation failed and the optional <m>objVar</m>
        argument is given, then the variable with that name is set to
        a validation error message. If the XML string is valid and the
        optional <m>objVar</m> argument is given, then the variable
        with that name is set to the empty string.</desc>
      </commanddef>
      
      <commanddef>
        <command><method>domvalidate</method> <m>domNode</m> <m>?objVar?</m></command>
        <desc>Returns true if the first argument is a valid tree or
        false otherwise. If validation failed and the optional
        <m>objVar</m> argument is given, then the variable with that
        name is set to a validation error message. If the dom tree is
        valid and the optional <m>objVar</m> argument is given, then
        the variable with that name is set to the empty string. </desc>
      </commanddef>
      
      <commanddef>
        <command><method>reportcmd</method></command>
        <desc>This method expects the name of a tcl command to be
        called in case of validation error. This command will be
        called with two arguments: the schema command, that is rasing
        the validation error, and an validation error code. The
        possible error codes are:
        <ul>
            <li>
            </li>
        </ul>
        </desc>
      </commanddef>

      <commanddef>
        <command><method>delete</method></command>
        <desc>This method deletes the validation command.</desc>
      </commanddef>

      <commanddef>
          <command><method>info</method> <m>?args?</m></command>
          <desc>This method bundles methods to query the state of and
          details about the schema command.
          <optlist>
              <optdef>
                  <optname>validationstate</optname>
                  <desc>This method returns the state of the validation command
                  with respect to validation state. The possible return values
                  and their meanings are:
                  <dl>
                      <dt>READY</dt><dd>The validation command is ready to start
                      validation</dd>
                      <dt>VALIDATING</dt><dd>The validation command is in the
                      process of validating input.</dd>
                      <dt>FINISHED</dt><dd>The validation has finished, no futher
                      events are expected.</dd>
                  </dl>
                  </desc>
              </optdef>
              <optdef>
                  <optname>vstate</optname>
                  <desc>This method is a shorter alias for validationstate; see there.</desc>
              </optdef>
              <optdef>
                  <optname>line</optname>
                  <desc>If the schema command is currently validating
                  this method returns the line part of the parsing
                  position information and the empty string in all
                  other cases. If the schema command is currently
                  post-validating a DOM tree there may be no position
                  information stored at certain or all nodes. The
                  empty string is returned in this cases.</desc>
              </optdef>
              <optdef>
                  <optname>column</optname>
                  <desc>If the schema command is currently validating
                  this method returns the column part of the parsing
                  position information and the empty string in all
                  other cases. If the schema command is currently
                  post-validating a DOM tree there may be no position
                  information stored at certain or all nodes. The
                  empty string is returned in this cases.</desc>
              </optdef>
              <optdef>
                  <optname>domNode</optname>
                  <desc>If the schema command is currently
                  post-validating a DOM tree this command returns the
                  current parent node command (the node, whose content
                  is currently validated) and the empty string
                  otherwhise. It is recommended that you don't use
                  this method. Or at least leave the DOM tree alone,
                  use it read-only.</desc>
              </optdef>
              <optdef>
                  <optname>nrForwardDefinitions</optname>
                  <desc>Returns how much element, elementtype and ref
                  pattern are referenced that aren't defined so far
                  (summed together).</desc>
              </optdef>
              <optdef>
                  <optname>definedElements</optname>
                  <desc>Returns in no particular order the defined
                  elements in the grammer as list. If an element is
                  namespaced its list entry will be itself a list with
                  two elements, with the name as first and the
                  namespace as second element.</desc>
              </optdef>
              <optdef>
                  <optname>expected</optname> <desc>Returns in no
                  particular order all posible next events (since the
                  last successful event match, if there was one) as a
                  list. If an element is namespaced its list entry
                  will be itself a list with two elements, with the
                  name as first and the namespace as second element.
                  If text is a possible next event the list entry will
                  be a two elements list, with #text as first element
                  and the empty space as second. If an any element
                  constraint is possible the list entry will be a two
                  elements list, with &lt;any> as first element and
                  the empty space as second. If an any element in a
                  certain namespace constraint is possible the list
                  entry will be a two elements list, with &lt;any> as
                  first element and the namespace as second. If
                  element end is a possible event the list entry will
                  be a two elements list with &lt;elementend> and the
                  empty string as second element.</desc>
              </optdef>
              <optdef>
                  <optname>definition name ?namespace?</optname>
                  <desc>Returns the code that defines the given
                  element. The command raises error if there isn' a
                  definition of that element.
                  </desc>
              </optdef>
              <optdef>
                  <optname>vaction ?name|namespace|text?</optname>
                  <desc>If the schema command is currently processing
                  a validation event this method returns information
                  about what the command is doing. If the command is
                  called without the optional argument the possible
                  return values and their meanings are:
                  <dl>
                      <dt>NONE</dt><dd>The schema command currently
                      doesn't process a validation event.</dd>
                      <dt>MATCH_ELEMENT_START</dt><dd></dd>
                      <dt>MATCH_ELEMENT_END</dt><dd></dd>
                      <dt>MATCH_TEXT</dt><dd></dd>
                      <dt>MATCH_ATTRIBUTE_TEXT</dt><dd></dd>
                      <dt>MATCH_GLOBAL</dt><dd></dd>
                      <dt>MATCH_DOM_KEYCONSTRAINT</dt><dd></dd>
                  </dl>
                  If called with one of the possible optional
                  arguments the command returns detail information
                  depending on current action.
                  <dl>
                      <dt>name</dt><dd>Return the name of the element
                      that has to match in case of
                      MATCH_ELEMENT_START. Return the name of the
                      closed element in case of MATCH_ELEMENT_END.
                      Returns the name of the attribute in case of
                      MATCH_ATTRIBUTE_TEXT. Return the name of the
                      parent element in case of MATCH_TEXT.</dd>
                      
                      <dt>namespace</dt><dd>Return the namespace of
                      the element that has to match in case of
                      MATCH_ELEMENT_START. Return the namespace of the
                      closed element in case of MATCH_ELEMENT_END.
                      Returns the namespace of the attribute in case
                      of MATCH_ATTRIBUTE_TEXT. Return the namespace of
                      the parent element in case of MATCH_TEXT.</dd>
                      
                      <dt>text</dt><dd>Return the text in case of
                      MATCH_TEXTReturns the value of the attribute in
                      case of MATCH_ATTRIBUTE_TEXT.</dd>
                  </dl>
                  </desc>
              </optdef>
              <optdef>
                  <optname>stack top|inside|associated</optname>
                  <desc>In Tcl scripts evaluated by validation this method
                  provides information about the current validation stack.
                  Called outside this context the method returns the empty
                  string.
                  <optlist>
                      <optdef>
                          <optname>top</optname>
                          <desc>Returns the element which content is currently
                          checked (the at the moment open element tag).
                          </desc>
                      </optdef>
                      
                      <optdef>
                          <optname>inside</optname>
                          <desc>Returns all currently open elements as a list.</desc>
                      </optdef>
                      
                      <optdef>
                          <optname>associated</optname>
                          <desc>Returns the data associated with the current top
                          most stack content particle or the empty string it there isn't.
                          </desc>
                      </optdef>
                  </optlist>
                  </desc>
              </optdef>
          </optlist>
          </desc>
      </commanddef>
      
      <commanddef>
        <command><method>reset</method></command>
        <desc>This method resets the validation command into state
        READY (while preserving the defined grammer).</desc>
      </commanddef>

    </commandlist>
  </section>

  <section>
    <title>Schema definition scripts</title>

    <p>Schema definition scripts are ordinary Tcl scripts that are
    evaluatend in the namespace tdom::schema. The below listed schema
    definition commands in this tcl namespace allow to define a wide
    variety of document structures. Every schema definition command
    establish a validation constraint on the content which has to
    match or must be optional to qualify the content as valid. It is a
    validation error if there is additional (not matched) content.</p>

    <p>The schema definition commands are:</p>

    <commandlist>
      <commanddef>
        <command><method>element</method> <m>name</m> <m>?quant?</m> <m>?&lt;definition script>?</m></command>
        <desc>If the optional argument <m>definition script</m> isn't
        given this command refers to the element defined with
        <m>defelement</m> with the name <m>name</m> in the current
        context namespace. If the <m>defelement script</m> argument is
        given, then the validation constraint expects an element with
        the name <m>name</m> in the current namespace with content
        "locally" defined by the <m>definition script</m>. Forward
        references to so far not defined elements or pattern or other
        local definitions of the same name inside the <m>definition
        script</m> are allowed. If a forward referenced element isn't
        defined until validation then only an empty element with name
        <m>name</m> and namespace <m>namespace</m> and no attributes
        matches. </desc>
      </commanddef>

      <commanddef>
        <command><method>ref</method> <m>name</m> <m>?quant?</m></command>
        <desc>This command refers to the content particle defined with
        <m>defpattern</m> with the name <m>name</m> in the current
        context namespace. Forward references to a so far not defined
        pattern or recursive references are allowed. If a forward
        referenced pattern isn't defined until validation no content
        whatsoever is expected ("empty match").</desc>
      </commanddef>

      <commanddef>
        <command><method>group</method> <m>?quant?</m> <m>&lt;definition script></m></command>
        <desc>This method allows to group a sequence of content
        particle, defined by the <m>definition script></m>, that have
        to match in this sequence order.</desc>
      </commanddef>
      
      <commanddef>
        <command><method>choice</method> <m>?quant?</m> <m>&lt;definition script></m></command>
        <desc>This schema contraint match if one of the top level
        content particle defined by the <m>definition script></m>
        match. If one of this top level content particle is optional
        this constraint matches the "empty match".
        </desc>
      </commanddef>

      <commanddef>
        <command><method>interleave</method> <m>?quant?</m> <m>&lt;definition script></m></command>
        <desc>This schema constraint match after every of the top level
        content particle defined by the <m>definition script></m>
        have matched in any arbitrary order.</desc>
      </commanddef>

      <commanddef>
        <command><method>mixed</method> <m>?quant?</m> <m>&lt;definition script></m></command>
        <desc>This schema constraint match for any text (including the
        empty one) and every top level content particle defined by the
        <m>definition script></m> with default quantifier *.</desc>
      </commanddef>

      <commanddef>
        <command><method>text</method> <m>?&lt;constraint script>|"type" typename?</m></command>
        <desc>Without the optional constraint script this validation
        constraint matches every string (including the empty one).
        With <m>constraint script</m> or with a given text type
        argument a text matching this script or the text type is
        expected. </desc>
      </commanddef>

      <commanddef>
        <command><method>any</method> <m>?namespace?</m> <m>?quant?</m></command>
        <desc>The any command matches every element (in the namespace
        <m>namespace</m>, if that is given) (with whatever attributes)
        or subtree, no matter if known within the schema or not.
        Please notice, that in case of no <m>namespace</m> argument is
        given this mean the quantifier * and + will eat up any
        elements until the enclosing element ends. If you really have
        a namespace that looks like a valid tDOM schema quantifier
        you'll have to spell out always all two arguments.</desc>
      </commanddef>

      <commanddef>
        <command><method>attribute</method> <m>name</m> <m>?quant?</m> <m>(?&lt;constraint script>|"type" typename?)</m></command>
        <desc>The attribute command defines a attribute (in no
        namespace) to the enclosing element. The first definition of
        <m>name</m> inside an element definition wins; later
        definitions of the same name are silently ignored. After the
        <m>name</m> argument there may be one of the quantifieres ? or
        !. If there is, this will be used. Otherwise the attribute
        will be required (must be present in the xml source). If there
        is one argument more this argument is evaluated as constraint
        script, defining the value constrains of the attribute.
        Otherwise, if there are two more arguments and the first of
        them is the bareword "type" then the following is used as a
        text type name. This command is only allowed at top level in
        the definition script of an defelement/element script.</desc>
      </commanddef>

      <commanddef>
        <command><method>nsattribute</method> <m>name</m> <m>namespace</m> <m>?quant?</m> <m>(?&lt;constraint script>|"type" typename?)</m></command>
        <desc>This command does the same as the command
        <m>attribute</m>, just for the attribute <m>name</m> in the
        namespace <m>namespace</m>.</desc>
      </commanddef>

      <commanddef>
        <command><method>namespace</method> <m>uri</m> <m>&lt;definition script></m></command>
        <desc>Evaluates the <m>definition script</m> with context
        namespace <m>uri</m>. Every element or ref command name will
        be looked up in the namespace <m>uri</m> and local defined
        element will be in that namespace.</desc>
      </commanddef>

      <commanddef>
        <command><method>tcl</method> <m>tclcmd</m> <m>?arg arg ...?</m></command>
        <desc>Evaluates the Tcl script <m>tclcmd arg arg ... </m> and
        the schema command appended to the argument list. This
        validation command is only allowed in strict sequential
        context (not in choice, mixed and interleave). If the return
        code is something else than 0 (TCL_OK) then this ia a
        validation error.</desc>
      </commanddef>

      <commanddef>
        <command><method>associate</method> <m>data</m></command>
        <desc>This command is only allowed top-level inside the
        definition scripts of the element, elementtype, pattern or
        interleave content particle. Associate the as argument given
        <m>data</m> with the currently defined content particle and
        may be requested in scripts evaluated while validating the
        content of that particle with the schema command method call
        <m>info stack associated</m>.</desc>
      </commanddef>
      
      <commanddef>
        <command><method>prefixns</method> <m>?prefixUriList?</m></command>
        <desc>This defines a prefix to namespace URI mapping exactly
        as a <i>schemacmd prefixns</i> call. This is meant as toplevel
        command of a <i>schemacmd define</i> script. This command is
        not allowed nested in an other definition script command and
        will raise error, if you call it there.</desc>
      </commanddef>

      <commanddef>
        <command><method>defelement</method> <m>name</m> <m>?namespace?</m> <m>&lt;definition script></m></command>
        <desc>This defines an element exactly as a <i>schemacmd
        defelement</i> call. This is meant as toplevel command of a
        <i>schemacmd define</i> script. This command is not allowed
        nested in an other definition script command and will raise
        error, if you call it there.</desc>
      </commanddef>

      <commanddef>
        <command><method>defelementtype</method> <m>name</m> <m>?namespace?</m> <m>&lt;definition script></m></command>
        <desc>This defines an elementtype exactly as a <i>schemacmd
        defelementtype</i> call. This is meant as toplevel command of a
        <i>schemacmd define</i> script. This command is not allowed
        nested in an other definition script command and will raise
        error, if you call it there.</desc>
      </commanddef>

      <commanddef>
        <command><method>defpattern</method> <m>name</m> <m>?namespace?</m> <m>&lt;definition script></m></command>
        <desc>This defines a named pattern exactly as a <i>schemacmd
        defpattern</i> call. This is meant as toplevel command of a
        <i>schemacmd define</i> script. This command is not allowed
        nested in an other definition script command and will raise
        error, if you call it there.</desc>
      </commanddef>

      <commanddef>
        <command><method>deftext</method> <m>name</m> <m>&lt;constraint script></m></command>
        <desc>This defines a named bundle of text constraints exactly
        as a <i>schemacmd deftext</i> call. This is meant as toplevel
        command of a <i>schemacmd define</i> script. This command is
        not allowed nested in an other definition script command and
        will raise error, if you call it there.</desc>
      </commanddef>
      
      <commanddef>
        <command><method>start</method> <m>name</m> <m>?namespace?</m></command>
        <desc>This command works exactly as a <i>schemacmd start</i>
        call. This is meant as toplevel command of a <i>schemacmd
        define</i> script. This command is not allowed nested in an
        other definition script command and will raise error, if you
        call it there.</desc>
      </commanddef>
    </commandlist>
    
  </section>

  <section>
    <title>Quantity specifier</title>

    <p>Serveral schema definition commands expects a quantifier as
    one of their arguments, which specifies how often the content
    particle specified by the command is expected. The valid values
    for a <m>quant</m> argument are:</p>

    <optlist>
      <optdef>
        <optname>!</optname>
        <desc>The content particle must occur exactly once in valid
        documents.</desc>
      </optdef>
    
      <optdef>
        <optname>?</optname>
        <desc>The content particle must occur at most once in valid
        documents.</desc>
      </optdef>
    
      <optdef>
        <optname>*</optname>
        <desc>The content particle may occur zero or more times in a
        row in valid documents.</desc>
      </optdef>
    
      <optdef>
        <optname>+</optname>
        <desc>The content particle may occur one or more times in a
        row in valid documents.</desc>
      </optdef>
    
      <optdef>
        <optname>n</optname>
        <desc>The content particle must occur n times in a row in
        valid documents. The quantifier must be an integer greater
        zero.</desc>
      </optdef>
    
      <optdef>
        <optname>{n m}</optname> <desc>The content particle must occur
        n to m times (both inclusive) in a row in valid documents. The
        quantifier must be a tcl list with two elements. Both elements
        must be integers, with n >= 0 and n &lt; m.</desc>
      </optdef>
    </optlist>

    <p>If an optional quantifier is not given then it defaults to * in
    case of the mixed command and to ! for all other commands.</p>
  </section>

  <section>
    <title>Text constraint scripts</title>

    <p>Text - parsed character data, as XML calles it - must sometimes
    be of a certain kind, must comply to some rules etc to be valid.
    The text constraint script arguments to the text, attribute,
    nsattribute and deftext commands allow the following text
    constraint commands to check text for certain properties.</p>

    <p>The text constraint commands are:</p>

    <commandlist>
      <commanddef>
        <command><cmd>integer</cmd> <m>?(xsd|tcl)?</m></command>
        <desc>This text constraint match if the text value could be
        parsed as an integer. If the optional argument to the command
        is <m>tcl</m> everthing that returns TCL_OK if feeded into
        Tcl_GetInt() matches. If the optional argument to the command
        is <m>xsd</m> then the constraint match if the value is a
        valid xsd:integer. Without argument <m>xsd</m> is the
        default.</desc>
      </commanddef>

      <commanddef>
        <command><cmd>negativeInteger</cmd> <m>?(xsd|tcl)?</m></command>
        <desc>This text constraint match the same text values as the
        <m>integer</m> text constraint (see there) with the additional
        constraint that the value must be &lt; zero.</desc>
      </commanddef>
      
      <commanddef>
        <command><cmd>nonNegativeInteger</cmd> <m>?(xsd|tcl)?</m></command>
        <desc>This text constraint match the same text values as the
        <m>integer</m> text constraint (see there) with the additional
        constraint that the value must be &gt;= zero.</desc>
      </commanddef>

      <commanddef>
        <command><cmd>nonPositiveInteger</cmd> <m>?(xsd|tcl)?</m></command>
        <desc>This text constraint match the same text values as the
        <m>integer</m> text constraint (see there) with the additional
        constraint that the value must be &lt;= zero.</desc>
      </commanddef>

      <commanddef>
        <command><cmd>positiveInteger</cmd> <m>?(xsd|tcl)?</m></command>
        <desc>This text constraint match the same text values as the
        <m>integer</m> text constraint (see there) with the additional
        constraint that the value must be &gt; zero.</desc>
      </commanddef>
      
      <commanddef>
        <command><cmd>fixed</cmd> <m>value</m></command>
        <desc>The text constraint only match if the text value is
        string equal to the given value.</desc>
      </commanddef>
      
      <commanddef>
        <command><cmd>tcl</cmd> <m>tclcmd</m> <m>?arg arg ...?</m></command>
        <desc>Evaluates the tcl script <m>tclcmd arg arg ... </m> and
        the text to validate appended to the argument list. The return
        value of the tcl command is interpreted as a boolean.</desc>
      </commanddef>

      <commanddef>
        <command><cmd>enumeration</cmd> <m>list</m></command>
        <desc>This text constraint match if the text value is equal to
        one element (respecting case and any whitespace) of the
        argument <m>list</m>, which has to be a valid Tcl list.
        </desc>
      </commanddef>
      <commanddef>
        <command><cmd>match</cmd> <m>?-nocase?</m> <m>glob_style_match_pattern></m></command>
        <desc>This text constraint match if the text value match the
        glob style pattern given as argument. It follows the rules of
        the Tcl [string match] command, see
        <url>https://www.tcl.tk/man/tcl8.6/TclCmd/string.htm#M35</url>.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>regexp</cmd> <m>expression</m></command>
        <desc>This text constraint match if the text value match the
        regular expression given as argument. <url>https://www.tcl.tk/man/tcl8.6/TclCmd/re_syntax.htm</url> describes the regular expression syntax</desc>
      </commanddef>
      <commanddef>
        <command><cmd>nmtoken</cmd></command>
        <desc>This text constraint match if the text value match the
        XML nmtoken production
        <url>https://www.w3.org/TR/xml/#NT-Nmtoken</url></desc>
      </commanddef>
      <commanddef>
        <command><cmd>nmtokens</cmd></command>
        <desc>This text constraint match if the text value match the
        XML nmtokens production
        <url>https://www.w3.org/TR/xml/#NT-Nmtokens</url></desc>
      </commanddef>
      <commanddef>
        <command><cmd>name</cmd></command>
        <desc>This text constraint match if the text value match the
        XML name production
        <url>https://www.w3.org/TR/xml/#NT-Name</url>. This means the
        text value must start with a letter, underscore (_), or colon (:),
        and may contain only letters, digits, underscores (_), colons
        (:), hyphens (-), and periods (.).</desc>
      </commanddef>
      <commanddef>
        <command><cmd>ncname</cmd></command>
        <desc>This text constraint match if the text value match the
        XML ncname production
        <url>https://www.w3.org/TR/xml-names/#NT-NCName</url>. This
        means the text value must start with a letter or underscore (_),
        and may contain only letters, digits, underscores (_), hyphens
        (-), and periods (.) (The only difference to the name
        constraint is that colons are not permitted.)</desc>
      </commanddef>
      <commanddef>
        <command><cmd>qname</cmd></command>
        <desc>This text constraint match if the text value match the
        XML qname production
        <url>https://www.w3.org/TR/xml-names/#NT-QName</url>. This
        means the text value is either a ncname or two ncnames joined
        by a colon (:).</desc>
      </commanddef>
      <commanddef>
        <command><cmd>number</cmd> <m>?(xsd|tcl)?</m></command>
        <desc>This text constraint match if the text value could be
        parsed as a number. If the optional argument to the command is
        <m>tcl</m> everthing that returns TCL_OK if feeded into
        Tcl_GetDouble() matches. If the optional argument to the command
        is <m>xsd</m> then the constraint match if the value is a
        valid xsd:decimal. Without argument <m>xsd</m> is the
        default.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>boolean</cmd> <m>?(xsd|tcl)?</m></command>
        <desc>This text constraint match if the text value could be
        parsed as a boolean. If the optional argument to the command is
        <m>tcl</m> everthing that returns TCL_OK if feeded into
        Tcl_GetBoolean() matches. If the optional argument to the command
        is <m>xsd</m> then the constraint match if the value is a
        valid xsd:boolean. Without argument <m>xsd</m> is the
        default.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>isodate</cmd></command>
        <desc>This text constraint match if the text value is a
        xsd:date. This is basically like an ISO 8601 date of the form
        JJJJ-MM-DD. It follows the date rules of the gregorian
        calendar for all dates. A preceding minus sign for bce dates
        is allowed. There is no year 0.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>maxLength</cmd> <m>length</m></command>
        <desc>This text constraint match if the length of the text
        value (in characters, not bytes) is at most <m>length</m>. The
        length argument must be an integer greater zero.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>minLength</cmd> <m>length</m></command>
        <desc>This text constraint match if the length of the text
        value (in characters, not bytes) is at least <m>length</m>.
        The length argument must be an integer greater zero.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>oneOf</cmd> <m>&lt;constraint script></m></command>
        <desc>This text constraint match if one of the text
        constraints defined in the argument <m>constraint script</m>
        match the text. It stops after the first match and probes the
        text constraints in the order of definition.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>allOf</cmd> <m>&lt;constraint script></m></command>
        <desc>This text constraint match if all of the text
        constraints defined in the argument <m>constraint script</m>
        match the text. It stops after the first match failues and
        probes the text constraints in the order of definition. Since
        the schema definition commmand <m>text</m> also expects all
        text constraints to match the text constraint <m>allOf</m> is
        useful mostly together with the <m>oneOf</m> text constraint
        commmand.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>strip</cmd> <m>&lt;constraint script></m></command>
        <desc>This text constraint command tests all text constraints
        in the evaluated <m>constraint script></m> with the text to
        test striped of all white space at start and end.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>split</cmd> <m>?type ?args??</m><m>&lt;constraint script></m></command>
        <desc><p>This text constraint command splits the text to test
        into a list of values and tests all elements of that list for
        the text constraints in the evaluated <m>constraint
        script></m>.</p>
        <p>The available types are:</p>
        <dl>
            <dt>whitespace</dt><dd>The text to split is striped of all
            white space at start and end splited into a list at any
            successive white space.</dd>
            <dt>tcl tclcmd ?arg ...?</dt><dd>The text to split is
            handed to the <m>tclcmd</m>, which is evaluated on global
            level, appended with every given arg and the text to split
            as last argument. This call must return a valid tcl list,
            which elements are tested..</dd>
        </dl>
        <p>The default in case no split type argument is given is
        <m>whitespace</m>.</p></desc>
      </commanddef>
      <commanddef>
        <command><cmd>id</cmd> <m>?keySpace?</m></command>
        <desc>This text constraint command marks the text as a
        document wide ID (to be referenced by an idref). Every ID
        value within a document must be unique. It isn't an error if
        the ID isn't actually referenced within the document. The
        optional argument <m>keySpace</m> does all this for a named
        key space. The key space "" (the empty sting) is another key
        space as the <m>id</m> command without keySpace
        argument.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>idref</cmd> <m>?keySpace?</m></command>
        <desc>This text constraint command expects the text to be a
        reference to an ID within the document. The referenced ID may
        be later in the document, that the reference. Several
        references within the document to one ID are possible.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>base64</cmd></command>
        <desc>This text constraint match if text is valid according to
        RFC 4648.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>hexBinary</cmd></command>
        <desc>This text constraint match if text is a sequence of
        binary octets in hexadecimal encoding, where each binary octet
        is a two-character hexadecimal number. Lowercase and uppercase
        letters A through F are permitted.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>unsignedByte</cmd></command>
        <desc>This text constraint match if the text value is a
        xsd:unsignedByte. This is an integer between 0 and 255, both
        included, optionally preceded by a + sign and leading
        zeros.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>unsignedShort</cmd></command>
        <desc>This text constraint match if the text value is a
        xsd:unsignedShort. This is an integer between 0 and 65535,
        both included, optionally preceded by a + sign and leading
        zeros.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>unsignedInt</cmd></command>
        <desc>This text constraint match if the text value is a
        xsd:unsignedInt. This is an integer between 0 and 4294967295,
        both included, optionally preceded by a + sign and leading
        zeros.</desc>
      </commanddef>
      <commanddef>
        <command><cmd>unsignedLong</cmd></command>
        <desc>This text constraint match if the text value is a
        xsd:unsignedLong. This is an integer between 0 and
        18446744073709551615, both included, optionally preceded by a
        + sign and leading zeros.</desc>
      </commanddef>
    </commandlist>
  </section>

  <section>
    <title>Local key constraints</title>

    <p>Document wide uniqueness and foreign key constraints are
    available with the text constraint commands id and idref.
    Keyspaces allow for sub-tree local uniqueness and foreign key
    constraints.</p>

    <commandlist>
        <commanddef>
            <command><cmd>keyspace</cmd> <m>&lt;names list></m> <m>&lt;constraint script></m></command>
            <desc>Any number of keyspaces are possible. A keyspace is
            either active or not. An inside a <m>constraint
            script</m> called keyspace with the same name does
            nothing.</desc>
        </commanddef>
    </commandlist>

    <p>This text constraint commands work with keyspaces:</p>

    <commandlist>
        <commanddef>
            <command><cmd>key</cmd> <m>&lt;name></m></command>
            <desc>If the keyspace with the name <m>&lt;name></m> is not
            active always matches. If the keyspace is active then
            reports error if there is already a key with the value.
            Otherwise, stores the value as key in this keyspace and
            matches.</desc>
        </commanddef>
        <commanddef>
            <command><cmd>keyref</cmd> <m>&lt;name></m></command>
            <desc>If the keyspace with the name <m>&lt;name></m> is not
            active always matches. If the keyspace is active then
            reports error if there is still no key as the value at the
            end of the keyspace <m>&lt;name></m>. Otherwise it
            matches.</desc>
        </commanddef>
    </commandlist>
    
  </section>

  <section>
    <title>Exampels</title>

    <p>The XML Schema Part 0: Primer Second Edition
    (<url>https://www.w3.org/TR/xmlschema-0/</url>) starts with this
    example schema:</p>

    <example>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">

  &lt;xsd:annotation>
    &lt;xsd:documentation xml:lang="en">
     Purchase order schema for Example.com.
     Copyright 2000 Example.com. All rights reserved.
    &lt;/xsd:documentation>
  &lt;/xsd:annotation>

  &lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/>

  &lt;xsd:element name="comment" type="xsd:string"/>

  &lt;xsd:complexType name="PurchaseOrderType">
    &lt;xsd:sequence>
      &lt;xsd:element name="shipTo" type="USAddress"/>
      &lt;xsd:element name="billTo" type="USAddress"/>
      &lt;xsd:element ref="comment" minOccurs="0"/>
      &lt;xsd:element name="items"  type="Items"/>
    &lt;/xsd:sequence>
    &lt;xsd:attribute name="orderDate" type="xsd:date"/>
  &lt;/xsd:complexType>

  &lt;xsd:complexType name="USAddress">
    &lt;xsd:sequence>
      &lt;xsd:element name="name"   type="xsd:string"/>
      &lt;xsd:element name="street" type="xsd:string"/>
      &lt;xsd:element name="city"   type="xsd:string"/>
      &lt;xsd:element name="state"  type="xsd:string"/>
      &lt;xsd:element name="zip"    type="xsd:decimal"/>
    &lt;/xsd:sequence>
    &lt;xsd:attribute name="country" type="xsd:NMTOKEN"
                   fixed="US"/>
  &lt;/xsd:complexType>

  &lt;xsd:complexType name="Items">
    &lt;xsd:sequence>
      &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded">
        &lt;xsd:complexType>
          &lt;xsd:sequence>
            &lt;xsd:element name="productName" type="xsd:string"/>
            &lt;xsd:element name="quantity">
              &lt;xsd:simpleType>
                &lt;xsd:restriction base="xsd:positiveInteger">
                  &lt;xsd:maxExclusive value="100"/>
                &lt;/xsd:restriction>
              &lt;/xsd:simpleType>
            &lt;/xsd:element>
            &lt;xsd:element name="USPrice"  type="xsd:decimal"/>
            &lt;xsd:element ref="comment"   minOccurs="0"/>
            &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/>
          &lt;/xsd:sequence>
          &lt;xsd:attribute name="partNum" type="SKU" use="required"/>
        &lt;/xsd:complexType>
      &lt;/xsd:element>
    &lt;/xsd:sequence>
  &lt;/xsd:complexType>

  &lt;!-- Stock Keeping Unit, a code for identifying products -->
  &lt;xsd:simpleType name="SKU">
    &lt;xsd:restriction base="xsd:string">
      &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/>
    &lt;/xsd:restriction>
  &lt;/xsd:simpleType>

&lt;/xsd:schema>
    </example>

    <p>A somewhat one-to-one translation of that into a tDOM schema
    defintion script would be:</p>

    <example>
tdom::schema schema      
schema define {

    # Purchase order schema for Example.com.
    # Copyright 2000 Example.com. All rights reserved.

    defelement purchaseOrder {ref PurchaseOrderType}

    foreach elm {comment name street city state product} {
        defelement $elm text
    }

    defpattern PurchaseOrderType {
        element shipTo ! {ref USAddress}
        element billTo ! {ref USAddress}
        element comment ?
        element items
        attribute orderDate isodate
    }

    defpattern USAddress {
        element name
        element street
        element city
        element state
        element zip ! {text number}
        attribute country ! {fixed "US"}
    }

    defelement items {
        element item * {
            element product
            element quantity ! {text integer}
            element USPrice ! {text number}
            element comment
            element shipDate ? {text isodate}
            attribute partNum ! {pattern "^\d{3}-[A-Z]{2}$"}
        }
    }
}
      
    </example>

    <p>The RELAX NG Tutorial
    (<url>http://relaxng.org/tutorial-20011203.html</url>) starts with
    this example:</p>

    <example>
Consider a simple XML representation of an email address book:

&lt;addressBook>
  &lt;card>
    &lt;name>John Smith&lt;/name>
    &lt;email>js@example.com&lt;/email>
  &lt;/card>
  &lt;card>
    &lt;name>Fred Bloggs&lt;/name>
    &lt;email>fb@example.net&lt;/email>
  &lt;/card>
&lt;/addressBook>

The DTD would be as follows:

&lt;!DOCTYPE addressBook [
&lt;!ELEMENT addressBook (card*)>
&lt;!ELEMENT card (name, email)>
&lt;!ELEMENT name (#PCDATA)>
&lt;!ELEMENT email (#PCDATA)>
]>

A RELAX NG pattern for this could be written as follows:

&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0">
  &lt;zeroOrMore>
    &lt;element name="card">
      &lt;element name="name">
        &lt;text/>
      &lt;/element>
      &lt;element name="email">
        &lt;text/>
      &lt;/element>
    &lt;/element>
  &lt;/zeroOrMore>
&lt;/element>
      
    </example>

    <p>This schema definition script will do the same:</p>

    <example>
tdom::schema schema      
schema define {
    defelement addressBook {
        element card *
    }
    defelement card {
        element name
        element email
    }
    foreach e {name email} {
        defelement $e {text}
    }
}
      
    </example>
</section>

<keywords>
    <keyword>Validation</keyword>
    <keyword>Postvalidation</keyword>
    <keyword>DOM</keyword>
    <keyword>SAX</keyword>
</keywords>
</manpage>
