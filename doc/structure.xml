<manpage id="structure" cat="structure" title="structure">
  <namesection>
    <name>tdom::structure</name>
    <desc>Create an XML structure validation command</desc>
  </namesection>

  <synopsis>
    <syntax>package require tdom

    <cmd>tdom::structure</cmd> <m>cmdName</m>
    </syntax>
  </synopsis>

  <section>
    <title>DESCRIPTION </title>    
    
    <p>This command creates validation commands with a simple API. The
    validation commands have methods to define an XML grammer and are 
    able to validate XML or DOM trees against this grammer.</p>

    <p>The valid methods of the created commands are:</p>

    <commandlist>
      <commanddef>
        <command><method>defelement</method> <m>name</m> <m>?namespace?</m> <m>definition script</m></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>defpattern</method> <m>name</m> <m>definition script</m></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>define</method> <m>definition script</m></command>
        <desc></desc>
      </commanddef>
      
      <commanddef>
        <command><method>start</method> <m>documentElement</m> <m>?namespace?</m></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>event</method> <m>(start|end|text)</m> <m>?event specific data</m></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>delete</method></command>
        <desc>This method deletes the validation command.</desc>
      </commanddef>

      <commanddef>
        <command><method>state</method></command>
        <desc>This method returns the state of the validation command with respect to validation state. The possible return values and their meanings are:
        <dl>
          <dt>READY</dt><dd>The validation command is ready to start
          validation</dd>
          <dt>VALIDATING</dt><dd>The validation command is in the
          process of validating input.</dd>
          <dt>FINISHED</dt><dd>The validation has finished, no futher
          events are expected.</dd>
        </dl>
        </desc>
      </commanddef>
      
      <commanddef>
        <command><method>reset</method></command>
        <desc>This method resets the validation command into state
        READY (while preserving the defined grammer).</desc>
      </commanddef>

    </commandlist>
  </section>

  <section>
    <title>Structure definition scripts</title>

    <p>Structure definition scripts are ordinary Tcl scripts that are
    evaluatend in the namespace tdom::structure. Several commands in
    this tcl namespace allows to define a wide variety of document
    structures.</p>

    <p>This commands are:</p>

    <commandlist>
      <commanddef>
        <command><method>element</method> <m>name</m> <m>?quant?</m> <m>?definition script?</m></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>ref</method> <m>name</m></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>group</method> <m>definition script</m></command>
        <desc></desc>
      </commanddef>
      
      <commanddef>
        <command><method>choice</method> <m>definition script?</m></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>interleave</method> <m>definition script</m></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>mixed</method> <m>definition script</m></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>text</method> <m>definition script</m></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>any</method></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>attribute</method> <m>definition script</m></command>
        <desc></desc>
      </commanddef>

      <commanddef>
        <command><method>namespace</method> <m>definition script</m></command>
        <desc></desc>
      </commanddef>
      
      <commanddef>
        <command><method>empty</method></command>
        <desc></desc>
      </commanddef>
    </commandlist>
    
  </section>
  
  <section>
    <title>Exampels</title>

    <p>The XML Schema Part 0: Primer Second Edition
    https://www.w3.org/TR/xmlschema-0/ starts with this example schema
    or grammar or Structure definition:</p>

    <example>
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">

  &lt;xsd:annotation>
    &lt;xsd:documentation xml:lang="en">
     Purchase order schema for Example.com.
     Copyright 2000 Example.com. All rights reserved.
    &lt;/xsd:documentation>
  &lt;/xsd:annotation>

  &lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/>

  &lt;xsd:element name="comment" type="xsd:string"/>

  &lt;xsd:complexType name="PurchaseOrderType">
    &lt;xsd:sequence>
      &lt;xsd:element name="shipTo" type="USAddress"/>
      &lt;xsd:element name="billTo" type="USAddress"/>
      &lt;xsd:element ref="comment" minOccurs="0"/>
      &lt;xsd:element name="items"  type="Items"/>
    &lt;/xsd:sequence>
    &lt;xsd:attribute name="orderDate" type="xsd:date"/>
  &lt;/xsd:complexType>

  &lt;xsd:complexType name="USAddress">
    &lt;xsd:sequence>
      &lt;xsd:element name="name"   type="xsd:string"/>
      &lt;xsd:element name="street" type="xsd:string"/>
      &lt;xsd:element name="city"   type="xsd:string"/>
      &lt;xsd:element name="state"  type="xsd:string"/>
      &lt;xsd:element name="zip"    type="xsd:decimal"/>
    &lt;/xsd:sequence>
    &lt;xsd:attribute name="country" type="xsd:NMTOKEN"
                   fixed="US"/>
  &lt;/xsd:complexType>

  &lt;xsd:complexType name="Items">
    &lt;xsd:sequence>
      &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded">
        &lt;xsd:complexType>
          &lt;xsd:sequence>
            &lt;xsd:element name="productName" type="xsd:string"/>
            &lt;xsd:element name="quantity">
              &lt;xsd:simpleType>
                &lt;xsd:restriction base="xsd:positiveInteger">
                  &lt;xsd:maxExclusive value="100"/>
                &lt;/xsd:restriction>
              &lt;/xsd:simpleType>
            &lt;/xsd:element>
            &lt;xsd:element name="USPrice"  type="xsd:decimal"/>
            &lt;xsd:element ref="comment"   minOccurs="0"/>
            &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/>
          &lt;/xsd:sequence>
          &lt;xsd:attribute name="partNum" type="SKU" use="required"/>
        &lt;/xsd:complexType>
      &lt;/xsd:element>
    &lt;/xsd:sequence>
  &lt;/xsd:complexType>

  &lt;!-- Stock Keeping Unit, a code for identifying products -->
  &lt;xsd:simpleType name="SKU">
    &lt;xsd:restriction base="xsd:string">
      &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/>
    &lt;/xsd:restriction>
  &lt;/xsd:simpleType>

&lt;/xsd:schema>
    </example>

    <p>A somewhat one-to-one translation of that into a tDOM structure
    defintion script would be:</p>

    <example>
tdom::structure grammar      
grammar define {

    # Purchase order schema for Example.com.
    # Copyright 2000 Example.com. All rights reserved.

    element purchaseOrder {ref PurchaseOrderType}

    element comment {text}

    defpattern PurchaseOrderType {
        element shipTo {ref USAddress}
        element billTo {ref USAddress}
        element comment ?
        element items
        attribute orderDate
    }

    defpattern USAddress {
        element name {text}
        element street {text}
        element city {text}
        element state {text}
        element zip {text}
        attribute country ! {text fixed "US"}
    }

    defelement items {
        element item * {
            element product ! {text}
            element quntity ! {text {maxExcluse 100}}
            element USPrice ! {text isNumber}
            element comment
            element shipDate ? {text isDate}
            attribute partNum ! {text {pattern "\d{3}-[A-Z]{2}"}}
        }
    }
}
      
    </example>

    <p>The RELAX NG Tutorial http://relaxng.org/tutorial-20011203.html
    starts with this example:</p>

    <example>
Consider a simple XML representation of an email address book:

&lt;addressBook>
  &lt;card>
    &lt;name>John Smith&lt;/name>
    &lt;email>js@example.com&lt;/email>
  &lt;/card>
  &lt;card>
    &lt;name>Fred Bloggs&lt;/name>
    &lt;email>fb@example.net&lt;/email>
  &lt;/card>
&lt;/addressBook>

The DTD would be as follows:

&lt;!DOCTYPE addressBook [
&lt;!ELEMENT addressBook (card*)>
&lt;!ELEMENT card (name, email)>
&lt;!ELEMENT name (#PCDATA)>
&lt;!ELEMENT email (#PCDATA)>
]>

A RELAX NG pattern for this could be written as follows:

&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0">
  &lt;zeroOrMore>
    &lt;element name="card">
      &lt;element name="name">
        &lt;text/>
      &lt;/element>
      &lt;element name="email">
        &lt;text/>
      &lt;/element>
    &lt;/element>
  &lt;/zeroOrMore>
&lt;/element>
      
    </example>

    <p>This structure definition script will do the same:</p>

    <example>
tdom::structure grammar      
grammar define {
    defelement addressBook {
        element card *
    }
    defelement card {
        element name
        element email
    }
    foreach e {name email} {
        defelement $e {text}
    }
}
      
    </example>
  </section>
</manpage>
